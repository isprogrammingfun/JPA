## 엔티티 매니저 팩토리와 엔티티 매니저


- 엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장인데, 공장을 만드는 비용은 상당히 크므로 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.
- 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. 보통 트랜잭션을 시작할 때 커넥션을 획득한다

## 영속성 컨텍스트


- JPA를 이해하는 데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity) → DB에 저장한다는 것이 아니라 영속성 컨텍스트를 통해 해당 Entity를 영속화 하는 것. 즉 entity를 영속성 컨텍스트라는 곳에 저장하는 것.
- 영속성 컨텍스트는 논리적인 개념에 가깝고, 눈에 보이지도 않는다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

## 엔티티의 생명주기


1. 비영속 (new/transient) 
- 영속성 컨텍스트나 데이터베이스와 전혀 관계가 없는 새로운 상태. 객체를 최초로 생성한 상태.
2. 영속 (managed)
- 영속성 컨텍스트에 관리되는 상태
- 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한다. 이때 DB에 저장된 건 아니다.
- 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라고 한다.
3. 준영속 (detached)
- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
- 특정 엔티티를 준영속 상태로 만들려면 em.detach()를 호출하면 된다.
- em.close()를 호출해 영속성 컨텍스트를 닫거나 em.clear()를 호출해 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다
4. 삭제 (removed)
- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

## 영속성 컨텍스트의 특징


1. 영속성 컨텍스트와 식별자 값
- 영속성 컨텍스트는 엔티티를 식별자 값 (@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다. 식별자 값이 없으면 예외가 발생한다.
2. 영속성 컨텍스트와 데이터베이스 저장
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영
3. 장점 
- 1차 캐시
    - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다. 쉽게 이야기하면 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 pk로 매핑한 식별자고 값은 엔티티 객체 자체의 값이다.
    - 조회 시, JPA는 DB에서 값을 먼저 찾는 것이 아니라, 컨텍스트에 있는 1차 캐시에서 먼저 찾는다.
    - 조회 하는 값이 1차 캐시에 없다면, 엔티티 매니저는 DB를 조회해 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.
    - 엔티티 매니저는 트랜잭션 단위로 보통 만들고 끝날 때 같이 종료한다. 예를 들어 고객 요청이 하나 들어오고 비즈니스가 끝나면 영속성 컨텍스트를 지운다. 이때 1차 캐시도 같이 지워진다. 그렇기 때문에 큰 장점이라 할 수는 없지만, 이 컨셉을 이용해 객체지향적이게 코드를 작성할 수 있는 장점은 있다.
- 영속 엔티티 동일성 보장
    - 자바 컬랙션과 동일하게 동일성 보장을 해준다.
- 트랜잭션을 지원하는 쓰기 지연
    - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아두고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데, 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.
    - 이렇게 하는 이유는 persist 때마다 DB에 쿼리를 날리면 성능 최적화를 할 수 있는 여지가 없기 때문이다.
- 엔티티 수정 변경 감지 (Dirty Checking)
    - 자바 컬렉션에서 하는 것 처럼 변경이 가능하다.
    - JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다. 트랜잭션이 커밋 되는 시점에 플러시가 호출되면서 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다. 변경점이 발견되면 Update 쿼리를 쓰기 지연 SQL 저장소에 만들어두고, 이를 DB에 반영하고 커밋한다.
    - 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
